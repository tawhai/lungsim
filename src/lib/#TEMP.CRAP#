      NITB=NIT(nb)
      NKTB=NKT(0,nb)
      NFTB=1

      DO nr=1,NRT
        DO noelem=1,NEELEM(0,nr)
          ne=NEELEM(noelem,nr)
          DO ns=1,NST(nb)+NAT(nb)
            SE(ns,nb,ne)=1.0D0
          ENDDO !ns
          IF(NKTB.GT.1.AND.NBI(nb).NE.1) THEN !scale factors not unit
            DO NAE=1,NLE(nb)
              nl=NLL(NAE,ne)
              IF(nl.GT.0) THEN
                ni=NPL(1,0,nl)

IF(IBT(1,ni,nb).EQ.2.OR.
     '            (IBT(1,ni,nb).EQ.3.AND.IBT(2,ni,nb).EQ.4).OR.
     '            ((IBT(1,ni,nb).EQ.5.OR.IBT(1,ni,nb).EQ.6).AND.
     '            IBT(2,ni,nb).EQ.4)) THEN
C                 Hermite, hermite simplex, or Hermite sectors.
                  ni2=NI1(ni+1,NITB)
                  IF(NITB.EQ.3) THEN
                    ni3=NI1(ni+2,NITB)
                  ELSE
                    ni3=ni2 !so that IF statement below doesn't fail
                  ENDIF
                  DO N=1,2
                    nn=NNL(N,NAE,nb)
 !                   !Added AJP 2-6-93
                    IF(IBT(1,NITB,nb).EQ.9) THEN !Fourier time basis
                      NNK=(nn-1)*NKTB*NFTB
                    ELSE
                      ns=0
                      DO nn2=1,nn-1
                        DO nk2=1,NKT(nn2,nb)
                          ns=ns+1
                        ENDDO !nk2
                      ENDDO !nn2
                      NNK=ns
                    ENDIF
C KAT 10Dec98: I don't think scale factors of all derivs should be set
C                   to 1 in this case.  The default code will set the
C                   appropriate scale factors to 1.
C                    IF(ITYP10(1).GT.1.AND.DABS(DL(N,nl)).LT.1.0D-6
C     '                           .AND.ni.EQ.1) THEN
C                      DO nk=2,NKT(nn,nb)
C                        SE(NNK+nk,nb,ne)=1.0D0
C                        NKI(ni)=nk !is this ok? probably not!
C                      ENDDO !nk
C                    ELSE
                    DO nk=2,NKT(nn,nb)
                      IF(NITB.EQ.1.OR.
     '                  (NITB.EQ.2.AND.IDO(nk,nn,ni2,nb).EQ.1).OR.
     '                  (NITB.EQ.3.AND.IDO(nk,nn,ni2,nb).EQ.1
     '                  .AND.IDO(nk,nn,ni3,nb).EQ.1)) THEN
C KAT 31Aug98: DL(1,nl) and DL(2,nl) are now calculated correctly in
C              LINCAL so averaging is not necessary.
C              I haven't checked angle scaling.  Comment by cpb below.
C                          IF(NBI(nb).EQ.6.OR.NBI(nb).EQ.7) THEN
CC                           ave. arc-length scaling
C                            AVERAGE=.FALSE. !unless another line is found
C                            NEXTNE=NXI((2*N-3)*ni,1,ne)
C                            IF(nextne.NE.0) THEN
C                              NEXTNL=NPL(1+N,0,nl)
C                              IF(nextnl.NE.0) THEN
C                                IF(JTYP2.EQ.2) THEN !Nonstd line mapping
C                                  IF(NPL(4,0,nl).EQ.0) THEN !no mapping
C                                    AVERAGE=.TRUE.
C                                  ELSE
CC                                   only average if the 2 line lengths
CC                                     have the same sign.
C                                    AVERAGE=
C     '                                DL(N,nl)*DL(3-N,NEXTNL).GT.0.0d0
C                                  ENDIF
C                                ELSE !Standard line mapping
C                                  AVERAGE=.TRUE.
C                                ENDIF
C                              ENDIF
C                            ENDIF
C                            IF(.NOT.AVERAGE) THEN
C                              SE(nk+NNK,nb,ne)=DL(N,nl)
C                            ELSE IF(NBI(nb).EQ.6) THEN !arithmetic mean
C                              SE(nk+NNK,nb,ne)=
C     '                          (DL(N,nl)+DL(3-N,NEXTNL))/2.0d0
C                            ELSE !IF(NBI(nb).EQ.7) THEN !harmonic mean
CC                             ensure denominator is not zero
C                              TEMP=DL(N,nl)*DL(3-N,NEXTNL)
C                              IF(TEMP.EQ.0.0d0) THEN
C                                SE(nk+NNK,nb,ne)=0.0d0
C                              ELSE
C                                SE(nk+NNK,nb,ne)=
C     '                            2.0d0*TEMP/(DL(N,nl)+DL(3-N,NEXTNL))
C                              ENDIF
C                            ENDIF
Cc cpb 28/3/95 Fix for angle scaling
C                          ELSE !not av. arc length scaling
                        SE(nk+NNK,nb,ne)=DL(N,nl)
C                          ENDIF
!news AAY 3 Aug 91 make it 1 if zero arc length
                        IF(DABS(SE(nk+NNK,nb,ne)).LT.1.0d-6)
     '                    SE(nk+NNK,nb,ne)=1.0d0
!newe
                        NKI(ni)=nk
                      ENDIF
                    ENDDO !nk
C                    ENDIF
                  ENDDO !N=1,2
                ENDIF
              ENDIF
            ENDDO !NAE (nl)

            IF(NKTB.GE.4) THEN
              IF(NITB.EQ.2) THEN
C!!!            This is temporary until NKI(ni) above is fixed
                NKI(1)=2
                NKI(2)=3
                NIB=3
                DO ni=3,NIB,-1
                  ni2=NI1(ni+1,3)
                  ni3=NI1(ni+2,3)
                  DO nn=1,NNT(nb)
                    ns=0
                    DO nn2=1,nn-1
                      DO nk2=1,NKT(nn2,nb)
                        ns=ns+1
                      ENDDO !nk2
                    ENDDO !nn2
                    NNK=ns
C!!! This seems like a weird loop?!? It would be better to
C!!! spell everything out like NITB=3 case below.
                    DO nk=4,NKT(nn,nb)
                      IF(IDO(nk,nn,ni2,nb).EQ.2.AND.IDO(nk,nn,ni3,nb)
     '                  .EQ.2) THEN
                        IF(IBT(1,NITB,nb).EQ.9) THEN !Fourier time basis
                          NNK=(nn-1)*NKTB*NFTB
                        ENDIF
                        SE(NNK+nk,nb,ne)=SE(NNK+NKI(ni2),nb,ne)
     '                    *SE(NNK+NKI(ni3),nb,ne)
                      ENDIF
                    ENDDO !nk
                  ENDDO !nn
                ENDDO !ni
              ELSE IF(NITB.EQ.3) THEN
                NIB=1
                DO ni=3,NIB,-1
                  DO nn=1,NNT(nb)
                    ns=0
                    DO nn2=1,nn-1
                      DO nk2=1,NKT(nn2,nb)
                        ns=ns+1
                      ENDDO !nk2
                    ENDDO !nn2
                    NNK=ns
                    IF(IBT(1,1,nb).EQ.2.AND.IBT(2,1,nb).EQ.1.AND
     '                .IBT(1,2,nb).EQ.2.AND.IBT(2,2,nb).EQ.1.AND
     '                .IBT(1,3,nb).EQ.2.AND.IBT(2,3,nb).EQ.1) THEN
C                     tricubic Hermite basis
                      IF(ni.EQ.1) THEN !Calc 2-3 and 123 cross products
                        SE(NNK+7,nb,ne)=SE(NNK+3,nb,ne)*SE(NNK+5,nb,ne)
c testing  error NPS 23/12/98 -old line is below and the new is above
c please leave the commented line below as the whole heart mechanics
c solutions currently are dependent on this old code- NPS 31/10/99
c                        SE(NNK+6,nb,ne)=SE(NNK+3,nb,ne)*SE(NNK+5,nb,ne)

                        SE(NNK+8,nb,ne)=SE(NNK+2,nb,ne)*SE(NNK+3,nb,ne)
     '                    *SE(NNK+5,nb,ne)
                      ELSE IF(ni.EQ.2) THEN !Calc 3-1 cross product
                        SE(NNK+6,nb,ne)=SE(NNK+2,nb,ne)*SE(NNK+5,nb,ne)
c testing  error NPS 23/12/98 -old line is below and the new is above
c please leave the commented line below as the whole heart mechanics
c solutions currently are dependent on this old code- NPS 31/10/99
c                      SE(NNK+7,nb,ne)=SE(NNK+2,nb,ne)*SE(NNK+5,nb,ne)
                      ELSE IF(ni.EQ.3) THEN !Calc 1-2 cross product
                        SE(NNK+4,nb,ne)=SE(NNK+2,nb,ne)*SE(NNK+3,nb,ne)
                      ENDIF
                    ELSE IF(IBT(1,1,nb).EQ.1.AND.IBT(2,1,nb).EQ.1
     '                  .AND.IBT(1,2,nb).EQ.2.AND.IBT(2,2,nb).EQ.1
     '                  .AND.IBT(1,3,nb).EQ.2.AND.IBT(2,3,nb).EQ.1
     '                  .OR.IBT(1,1,nb).EQ.2.AND.IBT(2,1,nb).EQ.1
     '                  .AND.IBT(1,2,nb).EQ.1.AND.IBT(2,2,nb).EQ.1
     '                  .AND.IBT(1,3,nb).EQ.2.AND.IBT(2,3,nb).EQ.1
     '                  .OR.IBT(1,1,nb).EQ.2.AND.IBT(2,1,nb).EQ.1
     '                  .AND.IBT(1,2,nb).EQ.2.AND.IBT(2,2,nb).EQ.1
     '                  .AND.IBT(1,3,nb).EQ.1.AND.IBT(2,3,nb).EQ.1) THEN
C                     Linear/bicubic-Hermite or
C                     Cubic-Hermite/Linear/Cubic-Hermite or
C                     Bicubic-Hermite/Linear basis
                      SE(NNK+4,nb,ne)=SE(NNK+2,nb,ne)*SE(NNK+3,nb,ne)
                    ELSE !other weird bases
                      ni2=NI1(ni+1,3)
                      ni3=NI1(ni+2,3)
C!!! This seems like a weird loop?!? It would be better to
C!!! spell everything out like above.
                      DO nk=4,NKT(nn,nb)
                        IF(IDO(nk,nn,ni2,nb).EQ.2.AND
     '                    .IDO(nk,nn,ni3,nb).EQ.2) THEN
                          IF(IBT(1,NITB,nb).EQ.9) THEN
C                           Fourier time basis
                            NNK=(nn-1)*NKTB*NFTB
                          ENDIF
                          SE(NNK+nk,nb,ne)=SE(NNK+NKI(ni2),nb,ne)
     '                      *SE(NNK+NKI(ni3),nb,ne)
                        ENDIF
                      ENDDO !nk
                    ENDIF !basis type
                  ENDDO !nn
                ENDDO !ni
              ENDIF !NITB
            ENDIF !NKTB.GE.4
          ENDIF !NKTB.GT.1
        ENDDO !noelem (ne)
      ENDDO !nr

      IF(IBT(1,NIT(nb),nb).EQ.9) THEN !Fourier time basis
!       copy spatial scaling factors into each Fourier coeff
        DO nr=1,NRT
          DO noelem=1,NEELEM(0,nr)
            ne=NEELEM(noelem,nr)
            ns=0
            DO nn=1,NNT(nb)
              DO na=1,IBT(2,NIT(nb),nb)
                DO nk=1,NKT(nn,nb)
                  ns=ns+1                    !time dof number
                  NSG=(nn-1)*NKTB*NFTB+nk    !dof number for const term
                  SE(ns,nb,ne)=SE(NSG,nb,ne)
                ENDDO !nk
              ENDDO !na
            ENDDO !nn
          ENDDO !noelem
        ENDDO !nr
      ENDIF !Fourier time basis

      IF(DOP) THEN
C KAT 14May01: Can't branch out of critical section.
C              Critical section is not essential.
CC$      call mp_setlock()
        WRITE(OP_STRING,'('' NLE('',I1,'')='',I2)') nb,NLE(nb)
        CALL WRITES(IODI,OP_STRING,ERROR,*9999)
        DO nr=1,NRT
          DO noelem=1,NEELEM(0,nr)
            ne=NEELEM(noelem,nr)
            WRITE(OP_STRING,
     '        '('' SE(ns,'',I1,'','',I4,''): '',(8E11.3))')
     '        nb,ne,(SE(ns,nb,ne),ns=1,NST(nb)+NAT(nb))
            CALL WRITES(IODI,OP_STRING,ERROR,*9999)
          ENDDO !noelem
        ENDDO!nr
CC$      call mp_unsetlock()
      ENDIF !DOP

      CALL EXITS('DLSE')
      RETURN
 9999 CALL ERRORS('DLSE',ERROR)
      CALL EXITS('DLSE')
      RETURN 1
      END


